// Copyright 2017-2019 The Verible Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Unit tests for VerilogLexer (from verilog.lex)
#include "verilog/parser/verilog_lexer.h"

#include <initializer_list>
#include <utility>

#include "gtest/gtest.h"
#include "absl/strings/string_view.h"
#include "common/lexer/lexer_test_util.h"
#include "common/text/token_info.h"
#include "verilog/parser/verilog_token_enum.h"

namespace verilog {
namespace {

// Removes non-essential tokens from token output stream, such as spaces.
class FilteredVerilogLexer : public VerilogLexer {
 public:
  explicit FilteredVerilogLexer(absl::string_view code) : VerilogLexer(code) {}

  const verible::TokenInfo& DoNextToken() override {
    do {
      VerilogLexer::DoNextToken();
    } while (!VerilogLexer::KeepSyntaxTreeTokens(GetLastToken()));
    return GetLastToken();
  }
};

// Some tests work on filtered tokens, others check unfiltered tokens.
using verible::GenericTestData;
// TODO(b/139743437): Upgrade GenericTestDataSequence to LexerTestData.
using verible::GenericTestDataSequence;
using verible::SimpleTestData;
using LexerTestData = verible::SynthesizedLexerTestData;

// Forwarding function to the template test driver function.
template <typename... Args>
static void TestLexer(Args&&... args) {
  verible::TestLexer<VerilogLexer>(std::forward<Args>(args)...);
}

// Forwarding function to the template test driver function.
template <typename... Args>
static void TestFilteredLexer(Args&&... args) {
  verible::TestLexer<FilteredVerilogLexer>(std::forward<Args>(args)...);
}

static std::initializer_list<LexerTestData> kCommentTests = {
    {{TK_COMMENT_BLOCK, "/**/"}},
    {{TK_COMMENT_BLOCK, "/***/"}},
    {{TK_COMMENT_BLOCK, "/*  */"}},
    {{TK_COMMENT_BLOCK, "/* foo */"}},
    {{TK_COMMENT_BLOCK, "/* foo\nbar */"}},
    {{TK_EOL_COMMENT, "//"}, {TK_NEWLINE, "\n"}},
    {{TK_EOL_COMMENT, "//"}, {TK_NEWLINE, "\r"}},
    {{TK_EOL_COMMENT, "// foo"}, {TK_NEWLINE, "\n"}},
    {{TK_EOL_COMMENT, "// bar"}, {TK_NEWLINE, "\r"}},
    {{TK_EOL_COMMENT, "//foo"}, {TK_NEWLINE, "\n"}},
    // {"// foo"},  // fails b/c expecting endline
};

// treating attributes lists as C-style comments,
// except they are not returned as comment blocks.
static std::initializer_list<SimpleTestData> kAttributeTests = {
    {"(**)"},        {"(*     *)"},
    {"(* x)*)"},     {"(* **  *)"},
    {"(***)"},       {"(** **)"},
    {"(*\n*)"},      {"(* style=flat *)"},
    {"(*foo=bar*)"}, {"(* style=flat, fill=empty *)"},
};

static std::initializer_list<LexerTestData> kAttributeSequenceTests = {
    {{TK_ATTRIBUTE, "(**)"}, {TK_ATTRIBUTE, "(**)"}},
    {{TK_ATTRIBUTE, "(* style=flat,\nfill=empty *)"}, {TK_NEWLINE, "\n"}},
    {{TK_ATTRIBUTE, "(*garbage\nGARBAGE*)"}, {TK_NEWLINE, "\n"}},
    {{TK_ATTRIBUTE, "(*\ntoken\nsoup\n*)"}, {TK_NEWLINE, "\n"}},
};

static std::initializer_list<LexerTestData> kMacroCallTests = {
    {{MacroCallId, "`FOO"}, '(', ')'},
    {{MacroCallId, "`FOO1"}, '(', ')', ';'},
    {{MacroCallId, "`FOO2"}, '(', ')'},
    {{MacroCallId, "`FOO3"}, '(', {MacroCallCloseToEndLine, ")"}, "\n"},
    {{MacroCallId, "`FOO4"}, '(', {MacroCallCloseToEndLine, ")"}, "\n", ';'},
    {{MacroCallId, "`FOO5"}, '(', {MacroCallCloseToEndLine, ")"}, "  ", "\n"},
    {{MacroCallId, "`FOO5b"}, '(', {MacroCallCloseToEndLine, ")"}, "  \n"},
    {{MacroCallId, "`FOO6"}, '(', ')', ';'},
    {{MacroCallId, "`FOO7"},
     '(',
     {MacroArg, "BAR"},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO8"}, '(', {MacroArg, "BAR"}, ')'},
    {{MacroCallId, "`FOO9"},
     {TK_SPACE, "  "},
     '(',
     {MacroArg, "BAR"},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO10"}, "  ", '(', {MacroArg, "BAR"}, ')'},
    {{MacroCallId, "`FOO11"},
     "  ",
     '(',
     {MacroArg, "\"bar\""},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO12"},
     '(',
     {MacroArg, "BAR"},
     ',',
     {MacroArg, "\"bar\""},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO13"},
     " ",
     '(',
     {MacroArg, "`BAR"},
     ',',
     {MacroArg, "\"bar\""},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO14"},
     " ",
     '(',
     {MacroArg, "`BAR"},
     ',',
     " ",
     {MacroArg, "\"bar\""},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO15"},
     '(',
     {MacroArg, "`BAR"},
     ',',
     " ",
     {MacroArg, "\"bar\""},
     ')'},
    // macro arg string literals containing balance characters:
    {{MacroCallId, "`FOO16"},
     '(',
     {MacroArg, "`BAR"},
     ',',
     " ",
     {MacroArg, "\"bar([{\""},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    // macro arg string literals containing balance characters:
    {{MacroCallId, "`FOO17"},
     '(',
     {MacroArg, "`BAR"},
     ',',
     " ",
     {MacroArg, "\"bar)]}\""},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO18"},
     '(',
     {MacroArg, "{1,2,3}"},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO19"},
     '(',
     {MacroArg, "BAR()"},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO20"},
     '(',
     {MacroArg, "`BAR()"},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO21"}, '(', {MacroArg, "`BAR()"}, ')'},
    {{MacroCallId, "`FOO22"},
     '(',
     {MacroArg, "{1,2,3}"},
     ',',
     {TK_SPACE, " "},
     {MacroArg, "`BAR()"},  // macro arg without trailing spaces
     {TK_SPACE, " "},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO22b"},
     '(',
     {MacroArg, "bar"},
     {TK_SPACE, " "},
     ',',
     {MacroArg, "none"},
     {TK_SPACE, " "},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO23"}, " ", '(', {MacroArg, "{{{}}((){})}"}, ')'},
    {{MacroCallId, "`FOO24"}, '(', {MacroArg, "{{{}}((){})}"}, ')'},
    {{MacroCallId, "`FOO25"},
     '(',
     {MacroArg, "{{{}}((){})}"},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO26"}, " ", '(', {TK_SPACE, "  "}, ')'},
    {{MacroCallId, "`FOO27"}, '(', {TK_NEWLINE, "\n"}, ')'},
    {{MacroCallId, "`FOO28"}, " ", '(', {TK_SPACE, "\t"}, ')'},
    {{MacroCallId, "`FOO29"}, '(', {TK_SPACE, " "}, ',', {TK_SPACE, " "}, ')'},
    {{MacroCallId, "`FOO30"}, '(', ',', ')'},
    {{MacroCallId, "`FOO30b"}, '(', ',', {TK_SPACE, "   "}, ')'},
    {{MacroCallId, "`FOO31"}, '(', ',', ',', ',', ')'},
    {{MacroCallId, "`FOO32"},
     '(',
     " ",
     ',',
     "\n",
     ',',
     "\n\n",
     ',',
     "   ",
     ')'},
    {{MacroCallId, "`FOO33"},
     '(',
     "  ",
     {MacroArg, "abc"},
     "  ",  // trailing spaces separated from preceding macro argument
     ',',
     " ",
     ')'},
    {{MacroCallId, "`FOO34"},
     '(',
     "  ",
     ',',
     "  ",
     {MacroArg, "def"},
     "  ",
     ')'},
    {{MacroCallId, "`FOO35"},
     '(',
     "  ",
     ',',
     "  ",
     {MacroArg, "def"},
     "  ",
     ',',
     " ",
     ')'},
    {{MacroCallId, "`FOO36"}, '(', ',', {MacroArg, "def"}, ',', ')'},
    {{MacroIdItem, "`uvm_func_new"}, {TK_NEWLINE, "\n"}},
    {{MacroIdentifier, "`uvm_func_new"}, ';', {TK_NEWLINE, "\n"}},
    {{MacroIdItem, "`uvm_func_new"}, {TK_SPACE, "      "}, "\n"},
    {{MacroIdItem, "`uvm_func_new"},
     "   ",
     {TK_EOL_COMMENT, "// comment"},
     "\n"},
    {{MacroIdItem, "`uvm_func_new"},
     "   ",
     {TK_COMMENT_BLOCK, "/* comment */"},
     "\n"},
    {{MacroIdItem, "`uvm_func_new"},
     "   ",
     {TK_COMMENT_BLOCK, "/* comment */"},
     "  \n"},
    {{MacroIdItem, "`uvm_func_new"},
     {TK_COMMENT_BLOCK, "/*C*/"},
     {TK_COMMENT_BLOCK, "/*D*/"},
     "  ",
     {TK_EOL_COMMENT, "//E"},
     "\n"},
    {{MacroIdItem, "`uvm_object_utils_end"}, {TK_NEWLINE, "\n"}},
    {{MacroIdItem, "`uvm_func_new"},
     {TK_NEWLINE, "\n"},
     {MacroIdItem, "`uvm_func_tew"},
     {TK_NEWLINE, "\n"}},
    {{MacroIdentifier, "`uvm_blah"},
     ';',
     " ",
     {MacroIdItem, "`uvm_blah"},
     "\n"},
    {{MacroIdentifier, "`macro"},
     " ",
     '+',
     " ",
     {MacroIdentifier, "`schmacro"},
     ';'},
    {{MacroIdentifier, "`macro"}, '+', {MacroIdentifier, "`schmacro"}, ';'},
    {{SymbolIdentifier, "lvalue"},
     " ",
     '=',
     " ",
     {MacroIdItem, "`schmacro"},
     "\n"},
    {{SymbolIdentifier, "lvalue"}, '=', {MacroIdItem, "`schmacro"}, "\n"},

    // with escaped identifiers in call args
    {{MacroCallId, "`FOO"}, '(', {MacroArg, "\\BAR"}, " ", ')'},
    {{MacroCallId, "`FOO"}, '(', {MacroArg, "\\BAR"}, "\t", ')'},
    {{MacroCallId, "`FOO"}, '(', {MacroArg, "\\BAR"}, "\n", ')'},
};

static std::initializer_list<GenericTestDataSequence>
    kUnfilteredMacroCallTests = {
        {"`uvm_func_new   // comment\n",
         {MacroIdItem, TK_SPACE, TK_EOL_COMMENT, TK_NEWLINE}},
        {"`uvm_func_new   /* comment */\n",
         {MacroIdItem, TK_SPACE, TK_COMMENT_BLOCK, TK_NEWLINE}},
        {"`uvm_func_new   /* comment */  \n",
         {MacroIdItem, TK_SPACE, TK_COMMENT_BLOCK, TK_SPACE, TK_NEWLINE}},
        {"`uvm_func_new/*C*//*D*/  //E\n",
         {MacroIdItem, TK_COMMENT_BLOCK, TK_COMMENT_BLOCK, TK_SPACE,
          TK_EOL_COMMENT, TK_NEWLINE}},
        {"`FOO1(  )  \n",
         {MacroCallId, '(', TK_SPACE, MacroCallCloseToEndLine, TK_SPACE,
          TK_NEWLINE}},
        {"`FOO2()  /* comment */ \n",
         {MacroCallId, '(', MacroCallCloseToEndLine, TK_SPACE, TK_COMMENT_BLOCK,
          TK_SPACE, TK_NEWLINE}},
        {"`FOO3()  // comment\n",
         {MacroCallId, '(', MacroCallCloseToEndLine, TK_SPACE, TK_EOL_COMMENT,
          TK_NEWLINE}},
        {"`FOO4() /* comment */ // comment\n",
         {MacroCallId, '(', MacroCallCloseToEndLine, TK_SPACE, TK_COMMENT_BLOCK,
          TK_SPACE, TK_EOL_COMMENT, TK_NEWLINE}},
        {"`FOO5()  /* comment */ /* comment */\n",
         {MacroCallId, '(', MacroCallCloseToEndLine, TK_SPACE, TK_COMMENT_BLOCK,
          TK_SPACE, TK_COMMENT_BLOCK, TK_NEWLINE}},
        {"`FOO6(a)  // comment\n",
         {MacroCallId, '(', MacroArg, MacroCallCloseToEndLine, TK_SPACE,
          TK_EOL_COMMENT, TK_NEWLINE}},
        {"`FOO2(a,b)  // comment\n",
         {MacroCallId, '(', MacroArg, ',', MacroArg, MacroCallCloseToEndLine,
          TK_SPACE, TK_EOL_COMMENT, TK_NEWLINE}},
};

static std::initializer_list<LexerTestData> kMacroDefineTests = {
    {{PP_define, "`define"},
     {TK_SPACE, " "},
     {PP_Identifier, "FOO"},
     {PP_define_body, ""},
     {TK_NEWLINE, "\n"}},
    {{PP_define, "`define"},
     {TK_SPACE, "    "},
     {PP_Identifier, "FOO"},
     {PP_define_body, ""},
     {TK_NEWLINE, "\n"}},
    {{PP_define, "`define"},
     {TK_SPACE, "    "},
     {PP_Identifier, "FOO"},
     "   ",
     {PP_define_body, ""},
     {TK_NEWLINE, "\n"}},
    {{PP_define, "`define"},
     {TK_SPACE, "\t"},
     {PP_Identifier, "FOO"},
     {PP_define_body, ""},
     "\n"},
    {{PP_define, "`define"},
     {TK_SPACE, "\t\t"},
     {PP_Identifier, "FOO"},
     '(',
     ')',
     " ",
     {PP_define_body, "foo()"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     "  ",
     {PP_define_body, "12"},
     "\n"},
    {{PP_define, "`define"},
     "\t",
     {PP_Identifier, "FOO"},
     "\t",
     {PP_define_body, "13"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     " ",
     {PP_define_body, "\\\n14"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     {PP_define_body, "\\\n"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     {PP_define_body, "\\\n15"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     ')',
     "  ",
     {PP_define_body, "bar()"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     ')',
     "  ",
     {PP_define_body, "bar(x);"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     " ",
     {PP_define_body, "\"hello\\world\""},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     ')',
     " ",
     {PP_define_body, "\"hello\\world\""},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "y"},
     ')',
     " ",
     {PP_define_body, "\"hello\\world\"\\\n\"goodbye.\""},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     ',',
     " ",
     {PP_Identifier, "y"},
     ')',
     "  ",
     {PP_define_body, "$bar(x, y);"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     ',',
     " ",
     {PP_Identifier, "y"},
     ')',
     "   ",
     {PP_define_body, "\\\n$bar(x, y);"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     ',',
     " ",
     {PP_Identifier, "y"},
     ',',
     " ",
     {PP_Identifier, "z"},
     ')',
     "   ",
     {PP_define_body, "\\\n$bar(x, y);\\\nzoo();"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "y"},
     ',',
     " ",
     {PP_Identifier, "z"},
     ')',
     "   ",
     {PP_define_body, "\\\nalways look on\\\n\tthe bright side of life"},
     "\n"},
    // 2 definitions:
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     "  ",
     {PP_define_body, "12"},
     "\n",
     {PP_define, "`define"},
     " ",
     {PP_Identifier, "ZOO"},
     '(',
     {PP_Identifier, "a"},
     ',',
     " ",
     {PP_Identifier, "b"},
     ')',
     "  ",
     {PP_define_body, "b - a"},
     "\n"},
    // definition with condition definitions inside body:
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "F"},
     '(',
     {PP_Identifier, "z"},
     ')',
     {PP_define_body,
      "\\\n"
      "`ifdef Z \\\n"
      "`define X z\\\n"
      "`else \\\n"
      "`define X 2 \\\n"
      "`endif"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "GOOD"},
     " ",
     {PP_define_body, "EVIL"},
     "\n",
     {TK_static, "static"},
     " ",
     {TK_void, "void"},
     " ",
     {SymbolIdentifier, "tokens"},
     "\n"},
    // macro parameters with defaults:
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     '=',
     {PP_default_text, "88"},
     ',',
     " ",
     {PP_Identifier, "y"},
     '=',
     {PP_default_text, "\"abc\""},
     ')',
     " ",
     {PP_define_body, "\\\n$bar(y, x);"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     '=',
     {PP_default_text, "\"88\""},
     ',',
     " ",
     {PP_Identifier, "y"},
     '=',
     {PP_default_text, "abc"},
     ')',
     " ",
     {PP_define_body, "\\\n$bar(y, x);"},
     "\n"},
    // macro parameters with defaults, padded with spaces
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     " ",
     '=',
     {TK_SPACE, " "},  // leading space
     {PP_default_text, "88"},
     {TK_SPACE, " "},  // trailing space
     ',',
     " ",
     {PP_Identifier, "y"},
     " ",
     '=',
     {TK_SPACE, " "},  // leading space
     {PP_default_text, "\"abc\""},
     {TK_SPACE, " "},  // trailing space
     ')',
     " ",
     {PP_define_body, "\\\n$bar(y, x);"},
     "\n"},
    // testing parenthesis balancing in PP_default_text
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     '=',
     {PP_default_text, "(a,(b,c))"},
     ',',
     " ",
     {PP_Identifier, "y"},
     " ",
     '=',
     " ",  // leading space
     {PP_default_text, "\"non)},{(sense\""},
     " ",  // trailing space
     ')',
     " ",
     {PP_define_body, "\\\nbar(y, x);"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     '=',
     {PP_default_text, "\"\""},
     ',',
     " ",
     {PP_Identifier, "y"},
     " ",
     '=',
     {PP_default_text, "(a,\"bc\")"},
     ')',
     " ",
     {PP_define_body, "\\\nbar(y, x);"},
     "\n"},
    // no line following continuation:
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "UNFINISHED"},
     " ",
     {PP_define_body, "blah + \\"},
     "\n"},
    // multiple blank newlines after empty definition body
    {{PP_define, "`define"},
     "    ",
     {PP_Identifier, "BAR"},
     {PP_define_body, ""},
     "\n\n\n"},
    // conditional define
    {{PP_ifndef, "`ifndef"},
     "  ",
     {PP_Identifier, "FOO"},
     "\n",
     {PP_define, "`define"},
     "    ",
     {PP_Identifier, "BAR"},
     {PP_define_body, ""},
     "\n\n",
     {PP_endif, "`endif"},
     "\n"},
};

static std::initializer_list<GenericTestDataSequence> kProtectedTests = {
    {"module foo;\n"
     "`protected\n"
     "`endprotected\n"
     "endmodule\n",
     {TK_module, TK_SPACE, SymbolIdentifier, ';', TK_NEWLINE, TK_NEWLINE,
      TK_endmodule, TK_NEWLINE}},
    {"abc\n"
     "`protected\n"
     "(*&^%$#@!!@#$%^&*(a8sayasd\n"
     "87y&*H*HYgyGYh@#BH)72361^&*\n"
     "`endprotected\n"
     "begin\n",
     {SymbolIdentifier, TK_NEWLINE, TK_NEWLINE, TK_begin, TK_NEWLINE}},
    {"task bar;\n"
     "// pragma protect begin_protected\n"
     "// pragma protect end_protected\n"
     "endtask\n",
     {TK_task, TK_SPACE, SymbolIdentifier, ';', TK_NEWLINE, TK_NEWLINE,
      TK_endtask, TK_NEWLINE}},
    {"end\n"
     "//pragma protect begin_protected\n"
     "(*&^%$#@!!@#$%^&*(a8sayasd\n"
     "87y&*H*HYgyGYh@#BH)72361^&*\n"
     "//pragma protect end_protected\n"
     "always\n",
     {TK_end, TK_NEWLINE, TK_NEWLINE, TK_always, TK_NEWLINE}},
    {"end\n"
     "`pragma protect begin_protected\n"
     "(*&^%$#@!!@#$%^&*(a8sayasd\n"
     "87y&*H*HYgyGYh@#BH)72361^&*\n"
     "`pragma protect end_protected\n"
     "begin\n",
     {TK_end, TK_NEWLINE, TK_NEWLINE, TK_begin, TK_NEWLINE}},
};

static std::initializer_list<SimpleTestData> kSymbolIdentifierTests = {
    {"a"},    {" a"},   {"\t\ta"},   {"\nb"},     {"_"},   {"_987"},
    {"_1u"},  {"_$"},   {"_$_"},     {"Foo"},     {"F00"}, {"Foo222"},
    {"_Foo"}, {"Foo$"}, {"Foo_Bar"}, {"Foo$Bar"},
};

static std::initializer_list<SimpleTestData> kEscapedIdentifierTests = {
    // escaped identifiers
    {"\\foo "},
    {"\\__ "},
    {"\\555 "},
    {"\\these.are[really]ugly "},
    {"\\5.6.7.8 "},
    {"\\)(*&^%$#@! "},
    {"\\]fdg[];'[as321=-+/.,>. "},
    {"\\..:;;{]{*&!6^$94* "},
};

static std::initializer_list<SimpleTestData> kMacroIdentifierTests = {
    // treat `identifier (macro-constants) like plain identifier
    {"`foo"},
    {"`foo789"},
    {"`___"},
    {"`_oo00OO"},
};

static std::initializer_list<GenericTestData> kKeywordTests = {
    {"1step", TK_1step},
    {"always", TK_always},
    {"and", TK_and},
    {"assign", TK_assign},
    {"begin", TK_begin},
    {"buf", TK_buf},
    {"bufif0", TK_bufif0},
    {"bufif1", TK_bufif1},
    {"case", TK_case},
    {"casex", TK_casex},
    {"casez", TK_casez},
    {"cmos", TK_cmos},
    {"deassign", TK_deassign},
    {"default", TK_default},
    {"defparam", TK_defparam},
    {"disable", TK_disable},
    {"edge", TK_edge},
    {"else", TK_else},
    {"end", TK_end},
    {"endcase", TK_endcase},
    {"endfunction", TK_endfunction},
    {"endmodule", TK_endmodule},
    {"endprimitive", TK_endprimitive},
    {"endspecify", TK_endspecify},
    {"endtable", SymbolIdentifier},  // is keyword in table context
    {"endtask", TK_endtask},
    {"event", TK_event},
    {"find", SymbolIdentifier},
    {"find_index", SymbolIdentifier},
    {"find_first", SymbolIdentifier},
    {"find_first_index", SymbolIdentifier},
    {"find_last", SymbolIdentifier},
    {"find_last_index", SymbolIdentifier},
    {"for", TK_for},
    {"force", TK_force},
    {"forever", TK_forever},
    {"fork", TK_fork},
    {"function", TK_function},
    {"highz0", TK_highz0},
    {"highz1", TK_highz1},
    {"if", TK_if},
    {"ifnone", TK_ifnone},
    {"initial", TK_initial},
    {"inout", TK_inout},
    {"input", TK_input},
    {"integer", TK_integer},
    {"join", TK_join},
    {"large", TK_large},
    {"macromodule", TK_macromodule},
    {"medium", TK_medium},
    {"module", TK_module},
    {"nand", TK_nand},
    {"negedge", TK_negedge},
    {"nmos", TK_nmos},
    {"nor", TK_nor},
    {"not", TK_not},
    {"notif0", TK_notif0},
    {"notif1", TK_notif1},
    {"or", TK_or},
    {"output", TK_output},
    {"parameter", TK_parameter},
    {"pmos", TK_pmos},
    {"posedge", TK_posedge},
    {"primitive", TK_primitive},
    {"pull0", TK_pull0},
    {"pull1", TK_pull1},
    {"pulldown", TK_pulldown},
    {"pullup", TK_pullup},
    {"rcmos", TK_rcmos},
    {"real", TK_real},
    {"realtime", TK_realtime},
    {"reg", TK_reg},
    {"release", TK_release},
    {"repeat", TK_repeat},
    {"rnmos", TK_rnmos},
    {"rpmos", TK_rpmos},
    {"rtran", TK_rtran},
    {"rtranif0", TK_rtranif0},
    {"rtranif1", TK_rtranif1},
    {"scalared", TK_scalared},
    {"small", TK_small},
    {"specify", TK_specify},
    {"specparam", TK_specparam},
    {"strong0", TK_strong0},
    {"strong1", TK_strong1},
    {"supply0", TK_supply0},
    {"supply1", TK_supply1},
    {"table", SymbolIdentifier},  // is keyword inside primitive context
    {"task", TK_task},
    {"time", TK_time},
    {"tran", TK_tran},
    {"tranif0", TK_tranif0},
    {"tranif1", TK_tranif1},
    {"tri", TK_tri},
    {"tri0", TK_tri0},
    {"tri1", TK_tri1},
    {"triand", TK_triand},
    {"trior", TK_trior},
    {"trireg", TK_trireg},
    {"vectored", TK_vectored},
    {"wait", TK_wait},
    {"wand", TK_wand},
    {"weak0", TK_weak0},
    {"weak1", TK_weak1},
    {"while", TK_while},
    {"wire", TK_wire},
    {"wor", TK_wor},
    {"xnor", TK_xnor},
    {"xor", TK_xor},
    {"$hold", TK_Shold},
    {"$nochange", TK_Snochange},
    {"$period", TK_Speriod},
    {"$recovery", TK_Srecovery},
    {"$setup", TK_Ssetup},
    {"$setuphold", TK_Ssetuphold},
    {"$skew", TK_Sskew},
    {"$width", TK_Swidth},
    {"$attribute", TKK_attribute},
    {"bool", TK_bool},
    {"automatic", TK_automatic},
    {"endgenerate", TK_endgenerate},
    {"generate", TK_generate},
    {"genvar", TK_genvar},
    {"localparam", TK_localparam},
    {"noshowcancelled", TK_noshowcancelled},
    {"pulsestyle_onevent", TK_pulsestyle_onevent},
    {"pulsestyle_ondetect", TK_pulsestyle_ondetect},
    {"showcancelled", TK_showcancelled},
    {"signed", TK_signed},
    {"unsigned", TK_unsigned},
    {"$fullskew", TK_Sfullskew},
    {"$recrem", TK_Srecrem},
    {"$removal", TK_Sremoval},
    {"$timeskew", TK_Stimeskew},
    {"cell", TK_cell},
    {"config", TK_config},
    {"design", TK_design},
    {"endconfig", TK_endconfig},
    {"incdir", TK_incdir},
    {"include", TK_include},
    {"instance", TK_instance},
    {"liblist", TK_liblist},
    {"library", TK_library},
    {"use", TK_use},
    {"wone", TK_wone},
    {"uwire", TK_uwire},
    {"alias", TK_alias},
    {"always_comb", TK_always_comb},
    {"always_ff", TK_always_ff},
    {"always_latch", TK_always_latch},
    {"assert", TK_assert},
    {"assume", TK_assume},
    {"before", TK_before},
    {"bind", TK_bind},
    {"bins", TK_bins},
    {"binsof", TK_binsof},
    {"bit", TK_bit},
    {"break", TK_break},
    {"byte", TK_byte},
    {"chandle", TK_chandle},
    {"class", TK_class},
    {"clocking", TK_clocking},
    {"const", TK_const},
    {"constraint", TK_constraint},
    {"context", TK_context},
    {"continue", TK_continue},
    {"cover", TK_cover},
    {"covergroup", TK_covergroup},
    {"coverpoint", TK_coverpoint},
    {"cross", TK_cross},
    {"dist", TK_dist},
    {"do", TK_do},
    {"endclass", TK_endclass},
    {"endclocking", TK_endclocking},
    {"endgroup", TK_endgroup},
    {"endinterface", TK_endinterface},
    {"endpackage", TK_endpackage},
    {"endprogram", TK_endprogram},
    {"endproperty", TK_endproperty},
    {"endsequence", TK_endsequence},
    {"enum", TK_enum},
    {"expect", TK_expect},
    {"export", TK_export},
    {"extends", TK_extends},
    {"extern", TK_extern},
    {"final", TK_final},
    {"first_match", TK_first_match},
    {"foreach", TK_foreach},
    {"forkjoin", TK_forkjoin},
    {"iff", TK_iff},
    {"ignore_bins", TK_ignore_bins},
    {"illegal_bins", TK_illegal_bins},
    {"import", TK_import},
    {"inside", TK_inside},
    {"int", TK_int},
    {"interface", TK_interface},
    {"intersect", TK_intersect},
    {"join_any", TK_join_any},
    {"join_none", TK_join_none},
    {"local::", TK_local_SCOPE},
    {"local", TK_local},
    {"logic", TK_logic},
    {"longint", TK_longint},
    {"matches", TK_matches},
    {"modport", TK_modport},
    {"new", TK_new},
    {"null", TK_null},
    {"package", TK_package},
    {"packed", TK_packed},
    {"priority", TK_priority},
    {"program", TK_program},
    {"property", TK_property},
    {"protected", TK_protected},
    {"pure", TK_pure},
    {"rand", TK_rand},
    {"randc", TK_randc},
    {"randcase", TK_randcase},
    {"randsequence", TK_randsequence},
    {"randomize", TK_randomize},
    {"std::randomize", TK_randomize},
    {"ref", TK_ref},
    {"return", TK_return},
    {"$root", TK_Sroot},
    {"sequence", TK_sequence},
    {"shortint", TK_shortint},
    {"shortreal", TK_shortreal},
    {"solve", TK_solve},
    {"static", TK_static},
    {"string", TK_string},
    {"struct", TK_struct},
    {"super", TK_super},
    {"tagged", TK_tagged},
    {"this", TK_this},
    {"throughout", TK_throughout},
    {"timeprecision", TK_timeprecision},
    {"timeunit", TK_timeunit},
    {"type", TK_type},
    {"typedef", TK_typedef},
    {"union", TK_union},
    {"unique", TK_unique},
    {"$unit", TK_Sunit},
    {"var", TK_var},
    {"virtual", TK_virtual},
    {"void", TK_void},
    {"wait_order", TK_wait_order},
    {"wildcard", TK_wildcard},
    {"with", TK_with},
    {"within", TK_within},
    {"timeprecision_check", TK_timeprecision_check},
    {"timeunit_check", TK_timeunit_check},
    {"accept_on", TK_accept_on},
    {"checker", TK_checker},
    {"endchecker", TK_endchecker},
    {"eventually", TK_eventually},
    {"global", TK_global},
    {"implies", TK_implies},
    {"let", TK_let},
    {"nexttime", TK_nexttime},
    {"reject_on", TK_reject_on},
    {"restrict", TK_restrict},
    {"s_always", TK_s_always},
    {"s_eventually", TK_s_eventually},
    {"s_nexttime", TK_s_nexttime},
    {"s_until", TK_s_until},
    {"s_until_with", TK_s_until_with},
    {"strong", TK_strong},
    {"sync_accept_on", TK_sync_accept_on},
    {"sync_reject_on", TK_sync_reject_on},
    {"unique0", TK_unique0},
    {"until", TK_until},
    {"until_with", TK_until_with},
    {"untyped", TK_untyped},
    {"weak", TK_weak},
    {"implements", TK_implements},
    {"interconnect", TK_interconnect},
    {"nettype", TK_nettype},
    {"soft", TK_soft},
    {"above", TK_above},
    {"abs", TK_abs},
    {"absdelay", TK_absdelay},
    {"abstol", TK_abstol},
    {"access", TK_access},
    {"acos", TK_acos},
    {"acosh", TK_acosh},
    {"ac_stim", TK_ac_stim},
    {"aliasparam", TK_aliasparam},
    {"analog", TK_analog},
    {"analysis", TK_analysis},
    {"asin", TK_asin},
    {"asinh", TK_asinh},
    {"atan", TK_atan},
    {"atan2", TK_atan2},
    {"atanh", TK_atanh},
    {"branch", TK_branch},
    {"ceil", TK_ceil},
    {"connect", TK_connect},
    {"connectmodule", TK_connectmodule},
    {"connectrules", TK_connectrules},
    {"continuous", TK_continuous},
    {"cos", TK_cos},
    {"cosh", TK_cosh},
    {"ddt", TK_ddt},
    {"ddt_nature", TK_ddt_nature},
    {"ddx", TK_ddx},
    {"discipline", TK_discipline},
    {"discrete", TK_discrete},
    {"domain", TK_domain},
    {"driver_update", TK_driver_update},
    {"endconnectrules", TK_endconnectrules},
    {"enddiscipline", TK_enddiscipline},
    {"endnature", TK_endnature},
    {"endparamset", TK_endparamset},
    {"exclude", TK_exclude},
    {"exp", TK_exp},
    {"final_step", TK_final_step},
    {"flicker_noise", TK_flicker_noise},
    {"floor", TK_floor},
    {"flow", TK_flow},
    {"from", TK_from},
    {"ground", TK_ground},
    {"hypot", TK_hypot},
    {"idt", TK_idt},
    {"idtmod", TK_idtmod},
    {"idt_nature", TK_idt_nature},
    {"inf", TK_inf},
    {"infinite", TK_infinite},
    {"initial_step", TK_initial_step},
    {"laplace_nd", TK_laplace_nd},
    {"laplace_np", TK_laplace_np},
    {"laplace_zd", TK_laplace_zd},
    {"laplace_zp", TK_laplace_zp},
    {"last_crossing", TK_last_crossing},
    {"limexp", TK_limexp},
    {"ln", TK_ln},
    {"log", TK_log},
    {"max", SymbolIdentifier},
    {"merged", TK_merged},
    {"min", SymbolIdentifier},
    {"nature", TK_nature},
    {"net_resolution", TK_net_resolution},
    {"noise_table", TK_noise_table},
    {"paramset", TK_paramset},
    {"potential", TK_potential},
    {"pow", TK_pow},
    {"resolveto", TK_resolveto},
    {"sin", TK_sin},
    {"sinh", TK_sinh},
    {"slew", TK_slew},
    {"split", TK_split},
    {"sqrt", TK_sqrt},
    {"tan", TK_tan},
    {"tanh", TK_tanh},
    {"timer", TK_timer},
    {"transition", TK_transition},
    {"units", TK_units},
    {"white_noise", TK_white_noise},
    {"wreal", TK_wreal},
    {"zi_nd", TK_zi_nd},
    {"zi_np", TK_zi_np},
    {"zi_zd", TK_zi_zd},
    {"zi_zp", TK_zi_zp},
    {"+=", TK_PLUS_EQ},
    {"-=", TK_MINUS_EQ},
    {"*=", TK_MUL_EQ},
    {"/=", TK_DIV_EQ},
    {"%=", TK_MOD_EQ},
    {"&=", TK_AND_EQ},
    {"|=", TK_OR_EQ},
    {"^=", TK_XOR_EQ},
    {"++", TK_INCR},
    {"--", TK_DECR},
    {"<=", TK_LE},
    {">=", TK_GE},
    {"=>", TK_EG},
    {"==?", TK_WILDCARD_EQ},
    {"==", TK_EQ},
    {"!=?", TK_WILDCARD_NE},
    {"!=", TK_NE},
    {"===", TK_CEQ},
    {"!==", TK_CNE},
    {"'{", TK_LP},
    {"<<", TK_LS},
    {">>", TK_RS},
    {">>>", TK_RSS},
    {"*>", TK_SG},
    {"<+", TK_CONTRIBUTE},
    {"+:", TK_PO_POS},
    {"-:", TK_PO_NEG},
    {"**", TK_POW},
    // { "(*", TK_PSTAR },  // ignored by lexer, treated as comment
    // { "*)", TK_STARP },  // ignored by lexer, treated as comment
    {".*", TK_DOTSTAR},
    {"||", TK_LOR},
    {"&&", TK_LAND},
    {"&&&", TK_TAND},
    {"~&", TK_NAND},
    {"~|", TK_NOR},
    {"~^", TK_NXOR},
    {"->", _TK_RARROW},  // This can disambiguate to different enums, depending
                         // on context.
    {"<->", TK_LOGEQUIV},
    {"::", TK_SCOPE_RES},
    {":=", TK_COLON_EQ},
    {":/", TK_COLON_DIV},
    {"##", TK_POUNDPOUND},
    {"[*", TK_LBSTAR},
    {"[*]", TK_LBSTARRB},
    {"[+]", TK_LBPLUSRB},
    {"[=", TK_LBEQ},
    {"[->", TK_LBRARROW},
};

static std::initializer_list<SimpleTestData> kSingleCharTokenTests = {
    {"}"}, {"{"}, {";"}, {":"}, {"["}, {"]"}, {","}, {"("}, {")"},
    {"#"}, {"="}, {"."}, {"@"}, {"&"}, {"!"}, {"?"}, {"<"}, {">"},
    {"%"}, {"|"}, {"^"}, {"~"}, {"+"}, {"*"}, {"/"}, {"-"}, {"\'"},
};

static std::initializer_list<SimpleTestData> kRealTimeTests = {
    // scientific units
    {"1e-3"},
    {"2e+3"},
    {"3e6"},
    {"4E6"},
    {"5.12e-6"},
    {"0e-0"},
    {"0e+0"},
    {"6e-12"},
    {"7e-100"},
    {"6.02e-23"},
    {"2.9e8"},
    // scaled units are for Verilog-AMS
    {"1u"},
    {"2a"},
    {"3f"},
    {"4m"},
    {"5p"},
    {"6k"},
    {"6K"},
    {"7M"},
    {"8G"},
    {"9T"},
    {"2.5n"},
    {"100p"},
    {"10.0p"},
    {"0.01m"},
    {"0m"},
};

static std::initializer_list<GenericTestDataSequence> kBasedNumberTests = {
    {"'0", {TK_UnBasedNumber}},
    {"'1", {TK_UnBasedNumber}},
    {"'x", {TK_UnBasedNumber}},
    {"'X", {TK_UnBasedNumber}},
    {"'z", {TK_UnBasedNumber}},
    {"'Z", {TK_UnBasedNumber}},
    {"'d0", {TK_DecBase, TK_DecDigits}},
    {"'d 0", {TK_DecBase, TK_DecDigits}},
    {"'d20", {TK_DecBase, TK_DecDigits}},
    {"'d20__", {TK_DecBase, TK_DecDigits}},
    {"'sd9", {TK_DecBase, TK_DecDigits}},
    {"'SD12", {TK_DecBase, TK_DecDigits}},
    {"'dx", {TK_DecBase, TK_XZDigits}},
    {"'d x", {TK_DecBase, TK_XZDigits}},
    {"'dx_", {TK_DecBase, TK_XZDigits}},
    {"'dZ", {TK_DecBase, TK_XZDigits}},
    {"'d?", {TK_DecBase, TK_XZDigits}},
    {"'B0", {TK_BinBase, TK_BinDigits}},
    {"'b1", {TK_BinBase, TK_BinDigits}},
    {"'b 1", {TK_BinBase, TK_BinDigits}},
    {"'bx", {TK_BinBase, TK_BinDigits}},
    {"'bz", {TK_BinBase, TK_BinDigits}},
    {"'b1100", {TK_BinBase, TK_BinDigits}},
    {"'bxX10Zz", {TK_BinBase, TK_BinDigits}},
    {"'b_x_X_10_Zz", {TK_BinBase, TK_BinDigits}},
    {"'o0", {TK_OctBase, TK_OctDigits}},
    {"'o000", {TK_OctBase, TK_OctDigits}},
    {"'o777", {TK_OctBase, TK_OctDigits}},
    {"'o 777", {TK_OctBase, TK_OctDigits}},
    {"'o_007_007_", {TK_OctBase, TK_OctDigits}},
    {"'h0", {TK_HexBase, TK_HexDigits}},
    {"'h 0", {TK_HexBase, TK_HexDigits}},
    {"'ha", {TK_HexBase, TK_HexDigits}},
    {"'he110", {TK_HexBase, TK_HexDigits}},
    {"'h_feed_face", {TK_HexBase, TK_HexDigits}},
    {"'h0_cafebabe_", {TK_HexBase, TK_HexDigits}},
    {"'h00d_f00d", {TK_HexBase, TK_HexDigits}},
    {"'hxXXxcaca", {TK_HexBase, TK_HexDigits}},
    {"'hcacazzZZ", {TK_HexBase, TK_HexDigits}},
    {"'he110???_000", {TK_HexBase, TK_HexDigits}},
};

static std::initializer_list<SimpleTestData> kTimeLiteralTests = {
    {"1fs"},    {"2ps"},    {"3ns"},      {"4us"},    {"5ms"}, {"6.6fs"},
    {"7.77ps"}, {"88.0ns"}, {"999.99us"}, {"10.0ms"}, {"66s"},
    // {"1 ms"}, {"11.0 ms"},  // only allowed in `timescale context
};

static std::initializer_list<SimpleTestData> kStringLiteralTests = {
    {"\"\""},
    {"\".\""},
    {"\"...\""},
    {"\":)\""},
    {"\"^ ^\""},
    {"\"O_o\""},
    {"\"foobar\""},
    {"\"foo bar\""},
    {"\"the\\\\great\\\\escape\""},
    {"\"the\\\"great\\\"escape\""},
    {"\"the\\nGREAT\\nescape\""},  // with line continuations
};

// tokens with special handling in lexer
static std::initializer_list<GenericTestDataSequence> kTrickyTests = {
    {"(*)", {'*'}},
    {":/ ", {TK_COLON_DIV, TK_SPACE}},
    {":/8", {TK_COLON_DIV, TK_DecNumber}},
    {"://\n", {':', TK_EOL_COMMENT, TK_NEWLINE}},
    {":/*ignore*/\n", {':', TK_COMMENT_BLOCK, TK_NEWLINE}},
    {"0:// case description\n",
     {TK_DecNumber, ':', TK_EOL_COMMENT, TK_NEWLINE}},
    {"FOO \\\nBAR;", {SymbolIdentifier, TK_SPACE, SymbolIdentifier, ';'}},
};

// make sure these are lexed as separate tokens
static std::initializer_list<GenericTestDataSequence> kSequenceTests = {
    {"+=>", {'+', TK_EG}},
    {"-=>", {'-', TK_EG}},
    {"###", {TK_POUNDPOUND, '#'}},
    {"####", {TK_POUNDPOUND, TK_POUNDPOUND}},
    {"[-12]", {'[', '-', TK_DecNumber, ']'}},
    {"[*2]", {TK_LBSTAR, TK_DecNumber, ']'}},
    {"[ *3]", {'[', '*', TK_DecNumber, ']'}},
    {"[=1]", {TK_LBEQ, TK_DecNumber, ']'}},
    {"[ =1]", {'[', '=', TK_DecNumber, ']'}},
    {"[->]", {TK_LBRARROW, ']'}},
    {"[ ->]", {'[', _TK_RARROW, ']'}},
    {"`WIDTH'd777", {MacroNumericWidth, TK_DecBase, TK_DecDigits}},
    {"`WIDTH'd`DIGITS", {MacroNumericWidth, TK_DecBase, MacroIdentifier}},
    {"`WIDTH 'h888", {MacroNumericWidth, TK_HexBase, TK_HexDigits}},
    {"`WIDTH 'h `DIGITS", {MacroNumericWidth, TK_HexBase, MacroIdentifier}},
    {"`WIDTH \t 'o654", {MacroNumericWidth, TK_OctBase, TK_OctDigits}},
    {"`WIDTH'b101", {MacroNumericWidth, TK_BinBase, TK_BinDigits}},
    {"`WIDTH'b10zx", {MacroNumericWidth, TK_BinBase, TK_BinDigits}},
    {"`WIDTH'b`DIGITS", {MacroNumericWidth, TK_BinBase, MacroIdentifier}},
    {"(*)(*)", {'*', '*'}},
    {"(*) (*)", {'*', '*'}},
    {"(* ) (*  )", {'*', '*'}},
};

static std::initializer_list<GenericTestDataSequence> kContextKeywordTests = {
    {"option", {SymbolIdentifier}},
    {"covergroup blah option blah endgroup option",
     {TK_covergroup, SymbolIdentifier, TK_option, SymbolIdentifier, TK_endgroup,
      SymbolIdentifier}},
    {"with covergroup with endgroup with",
     {TK_with, TK_covergroup, TK_with__covergroup, TK_endgroup, TK_with}},
};

static std::initializer_list<GenericTestDataSequence>
    kBuiltinMethodKeywordTests = {
        {". randomize()", {'.', TK_randomize, '(', ')'}},
        {".randomize with", {'.', TK_randomize, TK_with}},
        {"min . min min", {SymbolIdentifier, '.', TK_min, SymbolIdentifier}},
        {"min . minime min",
         {SymbolIdentifier, '.', SymbolIdentifier, SymbolIdentifier}},
        {"max.max max", {SymbolIdentifier, '.', TK_max, SymbolIdentifier}},
        {"max.maximum max",
         {SymbolIdentifier, '.', SymbolIdentifier, SymbolIdentifier}},
        {"find . find find",
         {SymbolIdentifier, '.', TK_find, SymbolIdentifier}},
        {".finder", {'.', SymbolIdentifier}},
        {"find_index . find_index find_index",
         {SymbolIdentifier, '.', TK_find_index, SymbolIdentifier}},
        {"find_first . find_first find_first",
         {SymbolIdentifier, '.', TK_find_first, SymbolIdentifier}},
        {"find_first_index.find_first_index find_first",
         {SymbolIdentifier, '.', TK_find_first_index, SymbolIdentifier}},
        {"find_last . find_last find_last",
         {SymbolIdentifier, '.', TK_find_last, SymbolIdentifier}},
        {"find_last_index.find_last_index find_last",
         {SymbolIdentifier, '.', TK_find_last_index, SymbolIdentifier}},
        {"unique . unique unique", {TK_unique, '.', TK_unique, TK_unique}},
        {"uniquely.uniquely uniquely",
         {SymbolIdentifier, '.', SymbolIdentifier, SymbolIdentifier}},
        {"unique_index . unique_index unique_index",
         {SymbolIdentifier, '.', TK_unique_index, SymbolIdentifier}},
        {"sort . sort sort",
         {SymbolIdentifier, '.', TK_sort, SymbolIdentifier}},
        {"rsort .rsort rsort",
         {SymbolIdentifier, '.', TK_rsort, SymbolIdentifier}},
        {"reverse .reverse reverse",
         {SymbolIdentifier, '.', TK_reverse, SymbolIdentifier}},
        {"shuffle .shuffle shuffle",
         {SymbolIdentifier, '.', TK_shuffle, SymbolIdentifier}},
        {"sum . sum sum", {SymbolIdentifier, '.', TK_sum, SymbolIdentifier}},
        {"product .product product",
         {SymbolIdentifier, '.', TK_product, SymbolIdentifier}},
        {"and .and and", {TK_and, '.', TK_and, TK_and}},
        {"or .or or", {TK_or, '.', TK_or, TK_or}},
        {"xor .xor xor", {TK_xor, '.', TK_xor, TK_xor}},
};

static std::initializer_list<GenericTestDataSequence> kEdgeTests = {
    {"edge [] 10", {TK_edge, '[', ']', TK_DecNumber}},
    {"edge\n[] z0", {TK_edge, '[', ']', SymbolIdentifier}},
    {"edge[10]", {TK_edge, '[', TK_edge_descriptor, ']'}},
    {"edge\n[z0]", {TK_edge, '[', TK_edge_descriptor, ']'}},
    {"edge [01 0x 1x x0 z1] 10",
     {TK_edge, '[', TK_edge_descriptor, TK_edge_descriptor, TK_edge_descriptor,
      TK_edge_descriptor, TK_edge_descriptor, ']', TK_DecNumber}},
    {"edge [0x, 10, x1,0z,1z] x0",
     {TK_edge, '[', TK_edge_descriptor, ',', TK_edge_descriptor, ',',
      TK_edge_descriptor, ',', TK_edge_descriptor, ',', TK_edge_descriptor, ']',
      SymbolIdentifier}},
    {"edge x0", {TK_edge, SymbolIdentifier}},
    {"edge x0 [ 10 ]", {TK_edge, SymbolIdentifier, '[', TK_DecNumber, ']'}},
};

static std::initializer_list<GenericTestDataSequence> kUDPTests = {
    {"primitive table endtable endprimitive",
     {TK_primitive, TK_table, TK_endtable, TK_endprimitive}},
    {"primitive table b:l; endtable endprimitive",
     {TK_primitive, TK_table, 'b', ':', 'l', ';', TK_endtable,
      TK_endprimitive}},
    {"primitive table B:L:H; endtable endprimitive",
     {TK_primitive, TK_table, 'b', ':', 'l', ':', 'h', ';', TK_endtable,
      TK_endprimitive}},
    {"primitive table b B l L h H f F r R x X n N p P 0 1 ? * - : ; "
     "endtable B L F H R 1 endprimitive",
     {TK_primitive,
      TK_table,
      'b',
      'b',
      'l',
      'l',
      'h',
      'h',
      'f',
      'f',
      'r',
      'r',
      'x',
      'x',
      'n',
      'n',
      'p',
      'p',
      '0',
      '1',
      '?',
      '*',
      '-',
      ':',
      ';',
      TK_endtable,
      SymbolIdentifier,
      SymbolIdentifier,
      SymbolIdentifier,
      SymbolIdentifier,
      SymbolIdentifier,
      TK_DecNumber,
      TK_endprimitive}},
    {"primitive table (?0) (?1) (?x) (?X) (?"
     "?) (01) (0x) (0X) (bx) (bX) "
     "(b0) (b1) (0?) (10) (1x) (1X) (1?) (x0) (X0) (x1) (X1) (x?) (X?) "
     "endtable b0 bx x1 X0 10 endprimitive",
     {TK_primitive,
      TK_table,
      '_',
      '+',
      '%',
      '%',
      '*',
      'r',
      'Q',
      'Q',
      'q',
      'q',
      'f',
      'r',
      'P',
      'f',
      'M',
      'M',
      'N',
      'F',
      'F',
      'R',
      'R',
      'B',
      'B',
      TK_endtable,
      SymbolIdentifier,
      SymbolIdentifier,
      SymbolIdentifier,
      SymbolIdentifier,
      TK_DecNumber,
      TK_endprimitive}},
    // TK_DecNumber inside UDP should be rejected, and will be caught by parser
    {"primitive table 321", {TK_primitive, TK_table, TK_OTHER}},
    {"primitive table 1010", {TK_primitive, TK_table, '1', '0', '1', '0'}},
    {"primitive table 10\t10", {TK_primitive, TK_table, '1', '0', '1', '0'}},
    {"primitive table 10\n`ifdef BLAH\n10",
     {TK_primitive, TK_table, '1', '0', PP_ifdef, PP_Identifier, '1', '0'}},
};

static std::initializer_list<GenericTestDataSequence> kUnfilteredUDPTests = {
    {"primitive table 10/*comment*/10",
     {TK_primitive, TK_SPACE, TK_table, TK_SPACE, '1', '0', TK_COMMENT_BLOCK,
      '1', '0'}},
};

static std::initializer_list<GenericTestData> kTimingCheckTests = {
    {"$hold", TK_Shold},           {"$nochange", TK_Snochange},
    {"$period", TK_Speriod},       {"$recovery", TK_Srecovery},
    {"$setup", TK_Ssetup},         {"$setuphold", TK_Ssetuphold},
    {"$skew", TK_Sskew},           {"$width", TK_Swidth},
    {"$fullskew", TK_Sfullskew},   {"$recrem", TK_Srecrem},
    {"$removal", TK_Sremoval},     {"$timeskew", TK_Stimeskew},
    {"$attribute", TKK_attribute},
};

static std::initializer_list<GenericTestData> kSystemTaskFunctionTests = {
    {"$display", SystemTFIdentifier},   {"$error", SystemTFIdentifier},
    {"$info", SystemTFIdentifier},      {"$warning", SystemTFIdentifier},
    {"$fatal", SystemTFIdentifier},     {"$finish", SystemTFIdentifier},
    {"$stop", SystemTFIdentifier},      {"$hammertime", SystemTFIdentifier},
    {"$__MAGIC__", SystemTFIdentifier}, {"$thechosen1", SystemTFIdentifier},
};

static std::initializer_list<GenericTestDataSequence> kPreprocessorTests = {
    {"", {}},
    {"`define true false\n", {PP_define, PP_Identifier, PP_define_body}},
    {"  `define SIMULATION\n", {PP_define, PP_Identifier, PP_define_body}},
    {"`elsif\n", {PP_elsif}},
    {"`elsif\nfoo", {PP_elsif, SymbolIdentifier}},
    {"`elsif foo\n", {PP_elsif, PP_Identifier}},
    {"`elsif foo  \n", {PP_elsif, PP_Identifier}},
    {"  `elsif foo  \n", {PP_elsif, PP_Identifier}},
    {"  `elsif foo\n", {PP_elsif, PP_Identifier}},
    {"  `define BAR\n", {PP_define, PP_Identifier, PP_define_body}},
    {"\t\t`define BEAR\n", {PP_define, PP_Identifier, PP_define_body}},
    {"`else\n", {PP_else}},
    {"`else // comment\n", {PP_else}},
    {"`else blah\n", {PP_else, SymbolIdentifier}},
    {"`endif\n", {PP_endif}},
    {"`endif bar\n", {PP_endif, SymbolIdentifier}},
    {"`ifdef evil\n", {PP_ifdef, PP_Identifier}},
    {"     `ifdef     dont_be_evil\n", {PP_ifdef, PP_Identifier}},
    {"     `undef\tdont_be_evil\t\n", {PP_undef, PP_Identifier}},
    {"`ifndef also_evil\n", {PP_ifndef, PP_Identifier}},
    {"`include \"lib/standard_cells.v\"\n", {PP_include, TK_StringLiteral}},
    {"`undef behavior\n", {PP_undef, PP_Identifier}},
    {"`ifdef god_mode\n"
     "`define private public\n"
     "`elsif hacker_mode\n"
     "  `elsif sneaky_mode  \n"
     "  `elsif squeaky_mode\n"
     "`else\n"
     "`endif\n",
     {PP_ifdef, PP_Identifier, PP_define, PP_Identifier, PP_define_body,
      PP_elsif, PP_Identifier, PP_elsif, PP_Identifier, PP_elsif, PP_Identifier,
      PP_else, PP_endif}},
};

static std::initializer_list<GenericTestDataSequence>
    kUnfilteredPreprocessorTests = {
        {"`else // comment\n", {PP_else, TK_SPACE, TK_EOL_COMMENT, TK_NEWLINE}},
};

static std::initializer_list<GenericTestDataSequence>
    kUnfilteredDirectiveTests = {
        {"`timescale 1ps/1ps\n",
         {DR_timescale, TK_SPACE, TK_TimeLiteral, '/', TK_TimeLiteral,
          TK_NEWLINE}},
        {"`pragma fragma\n", {DR_pragma, TK_NEWLINE}},
};

static std::initializer_list<GenericTestDataSequence> kDirectiveTests = {
    {"`timescale", {DR_timescale}},
    {"`timescale 1ps/1ps", {DR_timescale, TK_TimeLiteral, '/', TK_TimeLiteral}},
    {"  `timescale 1ps/1ps",
     {DR_timescale, TK_TimeLiteral, '/', TK_TimeLiteral}},
    {"`timescale 1s / 1ms",
     {DR_timescale, TK_TimeLiteral, '/', TK_TimeLiteral}},
    {"`timescale 100ps / 100ps",
     {DR_timescale, TK_TimeLiteral, '/', TK_TimeLiteral}},
    {"`timescale 100 ps / 100 ps",  // space allowed only in `timescale context
     {DR_timescale, TK_DecNumber, TK_timescale_unit, '/', TK_DecNumber,
      TK_timescale_unit}},
    {"`celldefine", {DR_celldefine}},
    {"`celldefine\nmodule", {DR_celldefine, TK_module}},
    {"`endcelldefine", {DR_endcelldefine}},
    {"`resetall", {DR_resetall}},
    {"`unconnected_drive blah ", {DR_unconnected_drive, SymbolIdentifier}},
    {"`nounconnected_drive", {DR_nounconnected_drive}},
    {"`default_decay_time blah", {DR_default_decay_time, SymbolIdentifier}},
    {"`default_decay_time infinite", {DR_default_decay_time, TK_infinite}},
    {"`default_trireg_strength blah",
     {DR_default_trireg_strength, SymbolIdentifier}},
    {"`delay_mode_path       ", {DR_delay_mode_path}},
    {"`delay_mode_unit blah", {DR_delay_mode_unit, SymbolIdentifier}},
    {"`delay_mode_zero blahblah", {DR_delay_mode_zero, SymbolIdentifier}},
    {"`disable_portfaults blah", {DR_disable_portfaults, SymbolIdentifier}},
    {"`enable_portfaults blah", {DR_enable_portfaults, SymbolIdentifier}},
    {"`suppress_faults blah", {DR_suppress_faults, SymbolIdentifier}},
    {"`nosuppress_faults blah", {DR_nosuppress_faults, SymbolIdentifier}},
    {"`uselib lib=schmoozelib\n", {DR_uselib}},
    {"`protect", {DR_protect}},
    {"`endprotect", {DR_endprotect}},
    {"`begin_keywords random \"keywords\"",
     {DR_begin_keywords, SymbolIdentifier, TK_StringLiteral}},
    {"`end_keywords", {DR_end_keywords}},
    {"`default_nettype blah", {DR_default_nettype, SymbolIdentifier}},
};

static std::initializer_list<GenericTestDataSequence> kLexicalErrorTests = {
    // TODO(fangism): Return different error enums for different errors.
    {"111wire", {TK_OTHER}},
    {"wire 111wire;", {TK_wire, TK_OTHER, ';'}},
    {"`111macro\n", {TK_OTHER}},
    {"`111macrocall()\n", {TK_OTHER, '(', ')'}},
    {"` spacebad\n", {TK_OTHER, SymbolIdentifier}},
    {"\"\n", {TK_OTHER}},
    {"\"unterminated string literal", {TK_OTHER}},
    {"\"unterminated string literal\n", {TK_OTHER}},
    {"\"unterminated \\\nstring \\\nliteral\n", {TK_OTHER}},
    {"/*", {TK_OTHER}},
    {"/*\n", {TK_OTHER}},
    {"/* interminated comment", {TK_OTHER}},
    // Rejected ACSII characters
    {"\x7F", {TK_OTHER}},
    {"\x80", {TK_OTHER}},
    {"\xFF", {TK_OTHER}},
};

TEST(VerilogLexerTest, LexicalErrors) { TestFilteredLexer(kLexicalErrorTests); }
TEST(VerilogLexerTest, Comments) { TestLexer(kCommentTests); }
TEST(VerilogLexerTest, Attributes) { TestLexer(kAttributeTests, TK_ATTRIBUTE); }
TEST(VerilogLexerTest, AttributesSequence) {
  TestLexer(kAttributeSequenceTests);
}
TEST(VerilogLexerTest, MacroCalls) { TestLexer(kMacroCallTests); }
TEST(VerilogLexerTest, MacroCallsUnfiltered) {
  TestLexer(kUnfilteredMacroCallTests);
}
TEST(VerilogLexerTest, MacroDefines) { TestLexer(kMacroDefineTests); }
TEST(VerilogLexerTest, SymbolIdentifiers) {
  TestFilteredLexer(kSymbolIdentifierTests, SymbolIdentifier);
}
TEST(VerilogLexerTest, EscapedIdentifiers) {
  TestFilteredLexer(kEscapedIdentifierTests, EscapedIdentifier);
}
TEST(VerilogLexerTest, MacroIdentifiers) {
  TestLexer(kMacroIdentifierTests, MacroIdentifier);
}
TEST(VerilogLexerTest, Protected) { TestLexer(kProtectedTests); }
TEST(VerilogLexerTest, Keywords) { TestFilteredLexer(kKeywordTests); }
TEST(VerilogLexerTest, SingleCharToken) {
  TestLexer(kSingleCharTokenTests, verible::SingleChar);
}
TEST(VerilogLexerTest, RealTime) { TestLexer(kRealTimeTests, TK_RealTime); }
TEST(VerilogLexerTest, BasedNumbers) { TestFilteredLexer(kBasedNumberTests); }
TEST(VerilogLexerTest, TimeLiteral) {
  TestLexer(kTimeLiteralTests, TK_TimeLiteral);
}
TEST(VerilogLexerTest, Tricky) { TestLexer(kTrickyTests); }
TEST(VerilogLexerTest, Sequence) { TestFilteredLexer(kSequenceTests); }
TEST(VerilogLexerTest, StringLiteral) {
  TestLexer(kStringLiteralTests, TK_StringLiteral);
}
TEST(VerilogLexerTest, Edges) { TestFilteredLexer(kEdgeTests); }
TEST(VerilogLexerTest, UDP) { TestFilteredLexer(kUDPTests); }
TEST(VerilogLexerTest, UDPUnfiltered) { TestLexer(kUnfilteredUDPTests); }
TEST(VerilogLexerTest, ContextKeywords) {
  TestFilteredLexer(kContextKeywordTests);
}
TEST(VerilogLexerTest, BuiltinMethods) {
  TestFilteredLexer(kBuiltinMethodKeywordTests);
}
TEST(VerilogLexerTest, TimingChecks) { TestFilteredLexer(kTimingCheckTests); }
TEST(VerilogLexerTest, SystemTaskFunctionChecks) {
  TestFilteredLexer(kSystemTaskFunctionTests);
}
TEST(VerilogLexerTest, Preprocessor) { TestFilteredLexer(kPreprocessorTests); }
TEST(VerilogLexerTest, PreprocessorUnfiltered) {
  TestLexer(kUnfilteredPreprocessorTests);
}
TEST(VerilogLexerTest, Directives) { TestFilteredLexer(kDirectiveTests); }
TEST(VerilogLexerTest, DirectivesUnfiltered) {
  TestLexer(kUnfilteredDirectiveTests);
}

}  // namespace
}  // namespace verilog
